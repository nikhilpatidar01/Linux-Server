### AWK Command

`AWK` एक बहुत शक्तिशाली और लचीला टूल है जिसका उपयोग हम फ़ाइलों से डेटा को प्रोसेस करने, पैटर्न ढूंढने और उन पर ऑपरेशन्स करने के लिए करते हैं। इसका मुख्य उपयोग टेक्स्ट फाइलों को प्रोसेस करने में होता है। यहाँ पर हम `AWK` की संरचना और कुछ प्रमुख उदाहरणों के साथ समझेंगे। 

---

### **AWK का संरचना (Structure of AWK)**

`AWK` का basic structure होता है:

```bash
awk 'BEGIN { action } { action } END { action }' input_file
```

यहाँ:
1. **BEGIN Block**: यह section **input file पढ़ने से पहले** execute होता है। इसका उपयोग initialization (जैसे headers print करना, या कुछ variables set करना) के लिए होता है।
2. **Main Body**: यहाँ हम वो काम करते हैं जो हर input line पर करना है, जैसे पैटर्न ढूंढना या डेटा को modify करना।
3. **END Block**: यह section **input file के बाद** execute होता है, जिसका उपयोग आमतौर पर summary देने या अंतिम result print करने के लिए किया जाता है।

---

### **AWK कमांड्स के उदाहरण**

आइए कुछ `AWK` कमांड्स के उदाहरणों को विस्तार से समझते हैं:

---

#### **Example 1: `/etc/passwd` से पूरी लाइन प्रिंट करना**

```bash
awk '{print $0}' /etc/passwd
```

- **व्याख्या**: यह कमांड पूरी `/etc/passwd` फाइल को प्रिंट करता है। `$0` पूरी लाइन को दर्शाता है।
- **आउटपुट**:
  ```
  root:x:0:0:root:/root:/bin/bash
  daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
  ...
  ```

---

#### **Example 2: `/etc/passwd` से फील्ड्स का चयन करना**

```bash
awk -F: '{print $1}' /etc/passwd
```

- **व्याख्या**: इस कमांड में `-F:` का मतलब है कि हम फील्ड्स को कोलन `:` से अलग कर रहे हैं। `$1` पहला फील्ड (जो आमतौर पर यूज़रनेम होता है) प्रिंट करता है।
- **आउटपुट**:
  ```
  root
  daemon
  bin
  ...
  ```

---

#### **Example 3: `/etc/passwd` से यूज़रनेम और पूरा नाम प्रिंट करना**

```bash
awk -F: '{print $1, $5}' /etc/passwd
```

- **व्याख्या**: यहाँ `$1` (यूज़रनेम) और `$5` (पूरा नाम) को प्रिंट किया जा रहा है।
- **आउटपुट**:
  ```
  root Root User
  daemon Daemon User
  bin Bin User
  ...
  ```

---

#### **Example 4: `/etc/passwd` और `/etc/shadow` दोनों से डेटा प्रिंट करना**

```bash
awk -F: '{print $1, $3, $5}' /etc/passwd /etc/shadow
```

- **व्याख्या**: यहाँ `/etc/passwd` और `/etc/shadow` दोनों को प्रोसेस किया जा रहा है। `$1` यूज़रनेम, `$3` यूज़र ID, और `$5` पूरा नाम प्रिंट करेगा।
- **आउटपुट**:
  ```
  root 0 Root User
  daemon 1 Daemon User
  bin 2 Bin User
  ...
  ```

---

#### **Example 5: `/etc/passwd` में "root" के लिए यूज़रनेम प्रिंट करना**

```bash
awk -F: '/root/{print $1}' /etc/passwd
```

- **व्याख्या**: यह कमांड उन लाइनों को सर्च करता है जिसमें "root" शब्द है और केवल `$1` (यूज़रनेम) प्रिंट करता है।
- **आउटपुट**:
  ```
  root
  ```

---

### **AWK में IF Conditions और पैटर्न मैचिंग**

AWK में हम पैटर्न के आधार पर डेटा को फिल्टर कर सकते हैं। यह बहुत शक्तिशाली है क्योंकि हम अपनी कंडीशन के आधार पर डेटा प्रोसेस कर सकते हैं।

#### **Example 6: यदि यूज़र ID 0 है, तो यूज़र का नाम प्रिंट करें**

```bash
awk -F: '$3 == 0 {print $1}' /etc/passwd
```

- **व्याख्या**: यहाँ `$3` (यूज़र ID) को चेक किया जा रहा है कि वह 0 है या नहीं। अगर 0 है तो यूज़रनेम (`$1`) प्रिंट होगा।
- **आउटपुट**:
  ```
  root
  ```

---

#### **Example 7: `/etc/passwd` में "bash" शेल के लिए यूज़र प्रिंट करना**

```bash
awk -F: '$7 == "/bin/bash" {print $1}' /etc/passwd
```

- **व्याख्या**: यह कमांड `/etc/passwd` में उन यूज़र्स को ढूंढेगा जिनका शेल `/bin/bash` है।
- **आउटपुट**:
  ```
  root
  user1
  ```

---

### **AWK से ifconfig आउटपुट प्रोसेस करना**

`ifconfig` नेटवर्क इंटरफेस की जानकारी देता है। हम AWK का उपयोग करके इस डेटा को आसानी से प्रोसेस कर सकते हैं।

#### **Example 8: ifconfig का पूरा आउटपुट प्रिंट करना**

```bash
ifconfig | awk '{print $0}'
```

- **व्याख्या**: यह कमांड `ifconfig` का पूरा आउटपुट प्रिंट करेगा।
- **आउटपुट**:
  ```
  enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.5  netmask 255.255.255.0  broadcast 192.168.1.255
        ether 08:00:27:97:73:29  txqueuelen 1000  (Ethernet)
        ...
  ```

---

#### **Example 9: ifconfig से IP Address प्रिंट करना**

```bash
ifconfig | awk '/inet /{print $2}'
```

- **व्याख्या**: यहाँ हम `ifconfig` के आउटपुट में `inet` शब्द वाली लाइनों को सर्च कर रहे हैं और उनका दूसरा फील्ड (IP Address) प्रिंट कर रहे हैं।
- **आउटपुट**:
  ```
  192.168.1.5
  ```

---

#### **Example 10: ifconfig से MAC Address प्रिंट करना**

```bash
ifconfig | awk '/ether /{print $2}'
```

- **व्याख्या**: यह कमांड `ether` शब्द के साथ लाइनें ढूंढेगा (जो MAC Address होता है) और MAC Address प्रिंट करेगा।
- **आउटपुट**:
  ```
  08:00:27:97:73:29
  ```

---

बिलकुल! अब मैं आपके लिए सभी उदाहरण हिंदी में समझाऊंगा, जिसमें हिंदी और इंग्लिश दोनों का मिक्स प्रयोग होगा। 

---

### **AWK Command Structure:**

**Syntax**:
```bash
awk 'BEGIN {code_in_BEGIN_section} 
     main_body {code_in_main_body_section} 
     END {code_in_END_section}'
```

**Explanation**:
- **BEGIN Section**: यह सेक्शन प्रोग्राम के **शुरू होने पर** execute होता है। यहाँ हम **initial setup** या **message** print कर सकते हैं।
- **Main Body**: यह सेक्शन डेटा को **process** करता है और उस पर conditions apply करता है।
- **END Section**: जब प्रोग्राम अपना काम पूरा कर लेता है, तब यह सेक्शन **execute** होता है।

---

### **1. Basic AWK Example with BEGIN, Main Body, and END**

```bash
ifconfig | awk 'BEGIN{print "======= IP ADD =========="} /inet/{print $0} END{print "=================="}'
```

**Input (Output of `ifconfig`)**:
```
inet 192.168.1.1 netmask 255.255.255.0 broadcast 192.168.1.255
```

**Output**:
```
======= IP ADD ==========
inet 192.168.1.1 netmask 255.255.255.0 broadcast 192.168.1.255
==================
```

**Explanation**:
- **BEGIN** section में हम एक initial message print कर रहे हैं: `======= IP ADD ==========`। 
- Main body में `/inet/` pattern match करके **IP address** print किया गया है।
- **END** section में final message print होता है: `==================`।

---

### **2. Print Specific Columns in a String**

```bash
echo "one two three four" | awk '{print $1}'
```

**Input**:
```
one two three four
```

**Output**:
```
one
```

**Explanation**:
- `$1` से हम **पहली कॉलम** (first column) को print कर रहे हैं। इस case में "one" print होता है।

---

### **3. Print Multiple Columns**

```bash
echo "one two three four" | awk '{print $1,$2}'
```

**Input**:
```
one two three four
```

**Output**:
```
one two
```

**Explanation**:
- `$1,$2` से हम **पहली और दूसरी कॉलम** को print कर रहे हैं। इस case में "one two" output आता है।

---

### **4. Replacing Column Values**

```bash
echo "one two three four" | awk '{$1="1"; print $0}'
```

**Input**:
```
one two three four
```

**Output**:
```
1 two three four
```

**Explanation**:
- `$1="1"` से हम **पहली कॉलम** की value को "1" से replace कर रहे हैं। फिर पूरे record को `$0` से print किया गया है।

---

### **5. Print Entire Line**

```bash
echo "one two three four" | awk '{print $0}'
```

**Input**:
```
one two three four
```

**Output**:
```
one two three four
```

**Explanation**:
- `$0` से **पूरी लाइन** print होती है, यानी जितना भी text दिया गया है, वो पूरा output में आता है।

---

### **6. AWK for IP Address Extraction (using `ifconfig`)**

```bash
ifconfig | awk '/inet/{print $2}'
```

**Input (Output of `ifconfig`)**:
```
inet 192.168.1.1 netmask 255.255.255.0 broadcast 192.168.1.255
```

**Output**:
```
192.168.1.1
```

**Explanation**:
- `/inet/` ko match karke hum sirf **IP address** (`$2` field) ko print kar rahe hain.

---

### **7. Using Field Separator (`-F`)**

```bash
awk -F: '{print $1, "home at", $6}' /etc/passwd
```

**Input (from `/etc/passwd`)**:
```
root:x:0:0:root:/root:/bin/bash
```

**Output**:
```
root home at /root
```

**Explanation**:
- `-F:` se hum **field separator** ko `:` set kar rahe hain, jisse `/etc/passwd` file ko easily parse kiya ja sakta hai.
- `$1` aur `$6` se **username** aur **home directory** ko print kiya gaya hai.

---

### **8. Filtering Users Based on UID**

```bash
awk -F: '$3>1000{print $0}' /etc/passwd
```

**Input (from `/etc/passwd`)**:
```
root:x:0:0:root:/root:/bin/bash
user1:x:1001:1001::/home/user1:/bin/bash
```

**Output**:
```
user1:x:1001:1001::/home/user1:/bin/bash
```

**Explanation**:
- `$3>1000` se hum sirf un users ko filter kar rahe hain jinki UID **1000 se zyada** hai.

---

### **9. Arithmetic Operations in AWK**

#### **Addition**

```bash
echo 4 6 | awk '{print $1 + $2}'
```

**Input**:
```
4 6
```

**Output**:
```
10
```

**Explanation**:
- `$1 + $2` se hum `4` aur `6` ka **addition** kar rahe hain. Result "10" print hota hai.

#### **Subtraction**

```bash
echo 4 6 | awk '{print $1 - $2}'
```

**Input**:
```
4 6
```

**Output**:
```
-2
```

**Explanation**:
- `$1 - $2` se hum `4` aur `6` ka **subtraction** kar rahe hain. Result "-2" print hota hai.

#### **Multiplication**

```bash
echo 4 6 | awk '{print $1 * $2}'
```

**Input**:
```
4 6
```

**Output**:
```
24
```

**Explanation**:
- `$1 * $2` se hum `4` aur `6` ka **multiplication** kar rahe hain. Result "24" print hota hai.

---

### **10. Searching and Pattern Matching in AWK**

```bash
ifconfig | awk '/inet6/{print $2}'
```

**Input (from `ifconfig`)**:
```
inet6 fe80::1c2b:3d4e:5f6a:7b8c prefixlen 64 scopeid 0x20
```

**Output**:
```
fe80::1c2b:3d4e:5f6a:7b8c
```

**Explanation**:
- `/inet6/` ko match kar ke **IPv6 address** ko print kiya gaya hai.

---

### **11. Using `-f` Option with AWK (Use Script File)**

```bash
awk -f test.txt /etc/passwd
```

**Explanation**:
- `-f` option ka use AWK script file ko run karne ke liye hota hai. **`test.txt`** file mein AWK commands stored hoti hain jo **`/etc/passwd`** file par execute hoti hain.

---

### **12. Filter Users with UID Greater than 1000**

```bash
awk -F: '$3>1000{print $0}' /etc/passwd
```

**Input (from `/etc/passwd`)**:
```
root:x:0:0:root:/root:/bin/bash
user1:x:1001:1001::/home/user1:/bin/bash
```

**Output**:
```
user1:x:1001:1001::/home/user1:/bin/bash
```

**Explanation**:
- Hum **UID** ko filter kar rahe hain aur un users ko print kar rahe hain jinki UID **1000 se zyada** hai.

---
### AWK Special Variables:

AWK में कुछ **special variables** होते हैं जो data processing को और भी आसान बनाते हैं। यह variables हमारे लिए text files, log files, या किसी भी structured data में से meaningful information निकालने में मदद करते हैं। इन variables का उपयोग कर हम data ko efficiently process kar sakte hain.

---

### 1. **NR: Number of Records**
- **NR** का मतलब है **Number of Records**, यानी कि AWK ने कितनी lines process की हैं। यह **total number of lines** को count करता है जो AWK ने पढ़ा है। 

#### **Usage**:
- यह variable हर line के लिए increment होता है।
- NR का use हम यह जानने के लिए कर सकते हैं कि AWK ने कितनी lines process की हैं।

#### **Example**:
```bash
echo -e "apple\nbanana\ncherry" | awk '{print "Line Number:", NR, "Content:", $0}'
```

**Input**:
```
apple
banana
cherry
```

**Explanation**:
- **NR** variable ने हर line का number track किया और line के साथ उसे print किया।
- `$0` variable से पूरी line print हो रही है।

**Output**:
```
Line Number: 1 Content: apple
Line Number: 2 Content: banana
Line Number: 3 Content: cherry
```

**Explanation**:
- **NR** ने **line number** count किया और उसे हर line के साथ print किया।
- जैसे ही AWK एक नई line process करता है, NR का value बढ़ता जाता है।

---

### 2. **NF: Number of Fields**
- **NF** का मतलब है **Number of Fields**, यानी कि किसी भी line में कितने **fields** हैं। यह उस line के अंदर space, tab, या custom delimiter (जो FS से define किया गया हो) के आधार पर fields को count करता है।

#### **Usage**:
- **NF** का उपयोग हम यह जानने के लिए कर सकते हैं कि किसी particular line में कितने fields हैं।
- `$1`, `$2`, `$3` इत्यादि का उपयोग कर हम specific fields को access कर सकते हैं।

#### **Example**:
```bash
echo -e "apple 10 1.5\nbanana 20 2.5\ncherry 30 3.5" | awk '{print "Line", NR, "has", NF, "fields."}'
```

**Input**:
```
apple 10 1.5
banana 20 2.5
cherry 30 3.5
```

**Explanation**:
- **NF** variable से हम जान सकते हैं कि हर line में कितने fields हैं।
- **NR** से line number print हो रहा है।
  
**Output**:
```
Line 1 has 3 fields.
Line 2 has 3 fields.
Line 3 has 3 fields.
```

**Explanation**:
- हर line में तीन fields हैं (जैसे apple, 10, 1.5)। तो **NF** का value **3** है।
- AWK ने तीन fields को space से अलग किया और count किया। 

---

### 3. **FS: Field Separator**
- **FS** का मतलब है **Field Separator**, यानी कि यह वो character है जिसका इस्तेमाल fields को अलग करने के लिए किया जाता है। डिफ़ॉल्ट रूप से **FS** space होता है, लेकिन इसे आप custom delimiter भी सेट कर सकते हैं।

#### **Usage**:
- **FS** को किसी भी delimiter (जैसे `:`, `,`, `|` इत्यादि) से सेट किया जा सकता है।
- यह AWK को बताता है कि fields को किस character के आधार पर अलग किया जाए।

#### **Example**:
```bash
echo -e "apple:10:1.5\nbanana:20:2.5\ncherry:30:3.5" | awk 'BEGIN {FS=":"} {print "First Field:", $1, "Second Field:", $2, "Third Field:", $3}'
```

**Input**:
```
apple:10:1.5
banana:20:2.5
cherry:30:3.5
```

**Explanation**:
- यहाँ पर **FS=":"** सेट किया गया है ताकि AWK `:` को field separator मान सके।
- `$1`, `$2`, `$3` से हम respective fields को print कर रहे हैं।

**Output**:
```
First Field: apple Second Field: 10 Third Field: 1.5
First Field: banana Second Field: 20 Third Field: 2.5
First Field: cherry Second Field: 30 Third Field: 3.5
```

**Explanation**:
- **FS=":"** के कारण AWK ने `:` को delimiter माना और तीन fields (apple, 10, 1.5) को अलग-अलग process किया।
- Fields को **$1**, **$2**, और **$3** से access किया।

---

### **Summary of Special Variables:**

| **Variable** | **Description**                                         | **Example**                                                                 |
|--------------|---------------------------------------------------------|-----------------------------------------------------------------------------|
| **NR**       | Number of Records (Total lines processed)              | `awk '{print NR}'` — prints the number of the current line.                  |
| **NF**       | Number of Fields (Fields in each record)               | `awk '{print NF}'` — prints the number of fields in each line.               |
| **FS**       | Field Separator (Specifies how fields are separated)   | `awk 'BEGIN {FS=":"} {print $1, $2}'` — sets `:` as field separator.         |

---

### **Use Cases:**

1. **BEGIN Block**:
   - **Purpose**: Program के शुरू होने पर initialization या messages print करने के लिए। 

2. **Main Body**:
   - **Purpose**: Data ko process karna aur conditions laga kar filter karna.

3. **END Block**:
   - **Purpose**: Program के अंत में final processing aur message print करने के लिए।

---

### **Practical Example**:

```bash
echo -e "apple:10:1.5\nbanana:20:2.5\ncherry:30:3.5" | awk 'BEGIN {FS=":"} {print "Fruit:", $1, "Price:", $2, "Weight:", $3} END {print "Processing complete."}'
```

**Input**:
```
apple:10:1.5
banana:20:2.5
cherry:30:3.5
```

**Explanation**:
- **BEGIN** block mein hum `FS=":"` set karte hain.
- Main body mein hum fruit ka naam, price aur weight print karte hain (`$1`, `$2`, `$3` ke through)।
- **END** block mein final message print hota hai।

**Output**:
```
Fruit: apple Price: 10 Weight: 1.5
Fruit: banana Price: 20 Weight: 2.5
Fruit: cherry Price: 30 Weight: 3.5
Processing complete.
```

**Conclusion**:
- **NR**, **NF**, aur **FS** AWK ke powerful tools hain, jo data processing ko simple aur flexible bana dete हैं। Inka use करके हम text manipulation, data extraction, aur formatting tasks ko efficiently handle कर सकते हैं।
- 
---
---

Awk Command Examples

https://www.geeksforgeeks.org/awk-command-unixlinux-examples/

WHAT CAN WE DO WITH AWK? 

1. AWK Operations: 
(a) Scans a file line by line 
(b) Splits each input line into fields 
(c) Compares input line/fields to pattern 
(d) Performs action(s) on matched lines 

2. Useful For: 
(a) Transform data files 
(b) Produce formatted reports 

3. Programming Constructs: 
(a) Format output lines 
(b) Arithmetic and string operations 
(c) Conditionals and loops 

Syntax:

awk options 'selection _criteria {action }' input-file > output-file
Options:  

-f program-file : Reads the AWK program source from the file 
                  program-file, instead of from the 
                  first command line argument.
-F fs            : Use fs for the input field separator
Sample Commands 

Example: 

Consider the following text file as the input file for all cases below: 

$cat > employee.txt 
ajay manager account 45000
sunil clerk account 25000
varun manager sales 50000
amit manager account 47000
tarun peon sales 15000
deepak clerk sales 23000
sunil peon sales 13000
satvik director purchase 80000 
1. Default behavior of Awk: By default Awk prints every line of data from the specified file.  

$ awk '{print}' employee.txt
Output:  

ajay manager account 45000
sunil clerk account 25000
varun manager sales 50000
amit manager account 47000
tarun peon sales 15000
deepak clerk sales 23000
sunil peon sales 13000
satvik director purchase 80000 
In the above example, no pattern is given. So the actions are applicable to all the lines. Action print without any argument prints the whole line by default, so it prints all the lines of the file without failure. 

2. Print the lines which match the given pattern. 

$ awk '/manager/ {print}' employee.txt 
Output:  

ajay manager account 45000
varun manager sales 50000
amit manager account 47000 
In the above example, the awk command prints all the line which matches with the ‘manager’. 

3. Splitting a Line Into Fields : For each record i.e line, the awk command splits the record delimited by whitespace character by default and stores it in the $n variables. If the line has 4 words, it will be stored in $1, $2, $3 and $4 respectively. Also, $0 represents the whole line.  

$ awk '{print $1,$4}' employee.txt 
Output:  

ajay 45000
sunil 25000
varun 50000
amit 47000
tarun 15000
deepak 23000
sunil 13000
satvik 80000 
In the above example, $1 and $4 represents Name and Salary fields respectively. 

Built-In Variables In Awk

Awk’s built-in variables include the field variables—$1, $2, $3, and so on ($0 is the entire line) — that break a line of text into individual words or pieces called fields. 

NR: NR command keeps a current count of the number of input records. Remember that records are usually lines. Awk command performs the pattern/action statements once for each record in a file. 
NF: NF command keeps a count of the number of fields within the current input record. 
FS: FS command contains the field separator character which is used to divide fields on the input line. The default is “white space”, meaning space and tab characters. FS can be reassigned to another character (typically in BEGIN) to change the field separator. 
RS: RS command stores the current record separator character. Since, by default, an input line is the input record, the default record separator character is a newline. 
OFS: OFS command stores the output field separator, which separates the fields when Awk prints them. The default is a blank space. Whenever print has several parameters separated with commas, it will print the value of OFS in between each parameter. 
ORS: ORS command stores the output record separator, which separates the output lines when Awk prints them. The default is a newline character. print automatically outputs the contents of ORS at the end of whatever it is given to print. 
Examples: 

Use of NR built-in variables (Display Line Number)  

$ awk '{print NR,$0}' employee.txt 
Output:  

1 ajay manager account 45000
2 sunil clerk account 25000
3 varun manager sales 50000
4 amit manager account 47000
5 tarun peon sales 15000
6 deepak clerk sales 23000
7 sunil peon sales 13000
8 satvik director purchase 80000 
In the above example, the awk command with NR prints all the lines along with the line number. 

Use of NF built-in variables (Display Last Field)  

$ awk '{print $1,$NF}' employee.txt 
Output:  

ajay 45000
sunil 25000
varun 50000
amit 47000
tarun 15000
deepak 23000
sunil 13000
satvik 80000 
In the above example $1 represents Name and $NF represents Salary. We can get the Salary using $NF , where $NF represents last field. 

Another use of NR built-in variables (Display Line From 3 to 6)  

$ awk 'NR==3, NR==6 {print NR,$0}' employee.txt 
Output:  

3 varun manager sales 50000
4 amit manager account 47000
5 tarun peon sales 15000
6 deepak clerk sales 23000 
More Examples

For the given text file:  

$cat > geeksforgeeks.txt

A    B    C
Tarun    A12    1
Man    B6    2
Praveen    M42    3
1) To print the first item along with the row number(NR) separated with ” – “ from each line in geeksforgeeks.txt:  

$ awk '{print NR "- " $1 }' geeksforgeeks.txt 
1 - A
2 - Tarun
3 – Manav    
4 - Praveen
2) To return the second column/item from geeksforgeeks.txt: 

The question should be:- To return the second column/item from geeksforgeeks.txt:

$ awk '{print $2}' geeksforgeeks.txt 
B
A12
B6
M42
3) To print any non empty line if present  

$ awk 'NF < 0' geeksforgeeks.txt
here NF should be 0 not less than and the user have to print the line number also:

correct answer : awk ‘NF == 0 {print NR}’  geeksforgeeks.txt

OR 

awk ‘NF <= 0 {print NR}’  geeksforgeeks.txt

0
4) To find the length of the longest line present in the file:  

$ awk '{ if (length($0) > max) max = length($0) } END { print max }' geeksforgeeks.txt
13
5) To count the lines in a file:  

$ awk 'END { print NR }' geeksforgeeks.txt 
3
6) Printing lines with more than 10 characters:  

$ awk 'length($0) > 10' geeksforgeeks.txt 
Tarun    A12    1
Praveen    M42    3
7) To find/check for any string in any specific column:  

$ awk '{ if($3 == "B6") print $0;}' geeksforgeeks.txt
8) To print the squares of first numbers from 1 to n say 6:  

$ awk 'BEGIN { for(i=1;i<=6;i++) print "square of", i, "is",i*i; }' 
square of 1 is 1
square of 2 is 4
square of 3 is 9
square of 4 is 16
square of 5 is 25
square of 6 is 36
 AWK command in Unix/Linux with examples – FAQs
What is awk command in Linux?

awk is a scripting language and command-line tool that allows you to manipulate data and generate reports. It works by scanning a file line by line, searching for patterns that match a given condition, and performing specified actions on those lines or fields within lines.


What does awk ‘{ print $1 }’ do?

The command awk '{ print $1 }' prints the first field of each line from the input data, where fields are typically whitespace-separated by default. For instance, if each line is a record with fields separated by spaces, $1 represents the first word in each line.


What is the full form of awk?

awk is named after its creators: Al Aho, Peter Weinberger, and Brian Kernighan. The name “awk” comes from the initials of their surnames. There is no “full form” in the traditional sense, as it’s simply an acronym of the authors’ names.

---
---
